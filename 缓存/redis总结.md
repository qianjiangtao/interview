#### 一，为什么要用缓存

1.高性能: 缓存数据，减少数据库压力

2.高并发: 直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据 

------



#### 二，redis 和 memcached 的区别

1,redis支持更丰富的数据类型（支持更复杂的应用场景）：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。

2,Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。

3,集群模式：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.

4,Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。



#### 三，redis 常见数据结构以及使用场景分析

#### 1. String

> **常用命令:** set,get,decr,incr,mget 等。

String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。

#### 2.Hash

> **常用命令：** hget,hset,hgetall 等。

Hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以Hash数据结构来存储用户信息，商品信息等等。比如下面我就用 hash 类型存放了我本人的一些信息：

```json
key=JavaUser293847
value={  “id”: 1,  “name”: “SnailClimb”,  “age”: 22,  “location”: “Wuhan, Hubei”}
```

#### 3.List

> **常用命令:** lpush,rpush,lpop,rpop,lrange等

list 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。

Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。

另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。

#### 5.Sorted Set

> **常用命令：** zadd,zrange,zrem,zcard等

和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。

**举例：** 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 SortedSet 结构进行存储。



#### 四，数据过期策略

- **定期删除**：redis默认是每隔 100ms 就**随机抽取**一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！
- **惰性删除** ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！



#### 五，内存数据淘汰策略

1. **volatile-lru**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰

2. **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

3. **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

4. **allkeys-lru**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）.

5. **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰

6. **no-enviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

   

#### 六，Redis持久化RDB与AOF比较

**1.rdb持久化方式的优缺点**

优点：

```
1.RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。比如
每6小时执行bgsave备份，并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。
2.Redis加载RDB恢复数据远远快于AOF的方式。
3.RDB在恢复大数据集时的速度比 AOF 的恢复速度要快。
```

缺点：

```
1.RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操
作，频繁执行成本过高。
2.RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新
版RDB格式的问题。
```

2.aof持久化方式的优缺点

优点:

```
1.实时性比较好，可以调整fsync策略,比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync。默认
是1秒执行一次，最多丢失1秒的数据
2.aof日志文件的命令通过非常可读的方式进行记录，这个非常适合做灾难性的误删
3.当aof文件过大时，自动地在后台对AOF进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合
```

缺点:

```
1.对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。
2.数据恢复比较慢，不适合做冷备。
```

**2.如何选择**

一般来说,如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据,但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快 。Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 `aof-use-rdb-preamble` 开启）。如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。

#### 七，redis 事务

Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。

在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。在 Redis 中，事务总是具有原子性（Atomicity)、一致性(Consistency)和隔离性（Isolation），并且当 Redis 运行在某种特定的持久化模式下时，事务也具有持久性（Durability）。



#### 八，缓存雪崩和缓存穿透问题解决方案

**缓存雪崩**

简介：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。

解决办法（中华石杉老师在他的视频中提到过，视频地址在最后一个问题中有提到）：

- 事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
- 事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉
- 事后：利用 redis 持久化机制保存的数据尽快恢复缓存

**缓存穿透**

简介：一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。

解决办法： 有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。



#### 九，集群方案

1，redis sentinel（无数据分片）

2，redis cluster

3，codis/kvStrore

4，tair

| 产品          | 结构                                                         | 扩/缩容                                                      | 高可用                                                       | client                                                       |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| redis cluster | 无中心                                                       | 手动，使用redis-trib.rb进行节点迁移，迁移期间服务可用        | 集群master采用gossip协议检查master可用性，master采用redis sentinel作为group的高可用方案 | 直连redis实例，增加MOVED等重定向命令处理，client不支持事务、pipeline、mget等命令 |
| codis         | 中心proxy                                                    | 手动，使用RESTful api进行节点迁移，迁移期间服务可用          | proxy检查master redis实例的可用性，某台master redis不可用时手动提升slave为master | client连proxy，由proxy根据key决定请求到具体那台实例上，client不支持事务，但支持pipeline、mget等命令 |
| tair          | configServer作为配置中心和监控dataServer，client直连dataServer | 手动，添加新的dataServer到configServer， configServer根据一致性hash重做节点对照表发送到dataServer和client，dataServer根据节点对照表进行数据迁移 | configServer通过心跳检测dataServer可用性，根据配置规则来决定是否采用备用节点 | 初始化和数据迁移时获取到节点对照表，client请求时根据key和节点对照表获取到key所在的dataServer机器，直连dataServer |

 

 

 

 

 